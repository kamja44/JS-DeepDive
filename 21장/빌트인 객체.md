1. [자바스크립트 객체의 분류](#자바스크립트-객체의-분류)
2. [표준 빌트인 객체](#표준-빌트인-객체)
3. [원시값과 래퍼 객체](#원시값과-래퍼-객체)
4. [전역 객체](#전역-객체)

# 자바스크립트 객체의 분류

- JS 객체는 크게 3개의 객체로 분류할 수 있다.

1. 표준 빌트인 객체

- ECMAScript 사양에 정의된 객체를 말하며, 애플리케이션 전역의 공통 기능을 제공한다.
  - JS 실행 환경과 관계없이 언제나 사용할 수 있다.

2. 호스트 객체

- ECMAScript 사양에 정의되어 있지 않지만, JS 실행 환경에서 추가로 제공하는 객체를 말한다.

3. 사용자 정의 객체

- 표준 빌트인 객체와 호스트 객체처럼 기본 제공되는 객체가 아닌 사용자가 직접 정의한 객체를 말한다.

# 표준 빌트인 객체

- Math, Reflect, JSON을 제외한 표준 빌트인 객체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체이다.
  - 생성자 함수 객체인 표준 빌트인 객체는 프로토타입 메서드와 정적 메서드를 제공하고 생성자 함수 객체가 아닌 표준 빌트인 객체는 정적 메서드만 제공한다.
- 표준 빌트인 객체인 String, Number, Boolean 등 생성자 함수로 호출하여 인스턴스 생성

```js
// String 생성자 함수에 의한 String 객체 생성
const strObj = new String("kamja"); // String {"kamja"}
console.log(typeof strObj); // object

// Number 생성자 함수에 의한 Number 객체 생성
const numObj = new Number(444); // Number {444}
console.log(typeof numObj); // object

// Boolean 생성자 함수에 의한 Boolean 객체 생성
const boolObj = new Boolean(true); // Boolean {true}
console.log(typeof boolObj); // object
```

생성자 함수인 표준 빌트인 객체가 생성한 인스턴스의 프로토타입은 표준 빌트인 객체의 prototype 프로퍼티에 바인딩된 객체이다.

- 예를 들어 표준 빌트인 객체인 String을 생성자 함수로 호출하여 생성한 String 인스턴스의 프로토타입은 String.prototype이다.

```js
// String 생성자 함수에 의한 Strng 객체 생성
const strObj = new String("kamja"); // String {"kamja"}
// String 생성자 함수를 통해 생성한 strObj 객체의 프로토타입은 String.prototype이다.
console.log(Object.getPrototypeOf(strObj) === String.prototype); // true
```

- 표준 빌트인 객체의 prototype 프로퍼티에 바인딩된 객체는 다양한 기능의 빌트인 프로토타입 메서드를 제공한다. 또한, 표준 빌트인 객체는 인스턴스 없이도 호출 가능한 빌트인 정적 메서드를 제공한다.

```js
// Number 생성자 함수에 의한 Number 객체 생성
const numObj = new Number(1.5); // Number {1.5}
// toFixed는 Number.prototype의 프로토타입 메서드이다.
// Number.prototype.toFixed는 소수점 자리를 반올림하여 문자열로 반환한다.
console.log(numObj.toFixed()); // 2
// isInteger는 Number의 정적 메서드이다.
// Number.isIntger는 인수가 정수인지 검사하여 그 결과를 Boolean으로 반환한다.
console.log(Number.isInteger(0.5)); // false
```

# 원시값과 래퍼 객체

- 원시값은 객체가 아니므로 프로퍼티나 메서드를 가질 수 없는데도 원시값인 문자열이 마치 객체처럼 동작한다.

```js
const str = "hello";
// 원시 타입인 문자열이 프로퍼티와 메서드를 갖고 있는 객체처럼 동작한다.
console.log(str.length); // 5
console.log(str.toUpperCase()); // HELLO
```

- 원시값인 문자열, 숫자, 불리언 값의 경우 객체처럼 마침표 표기법(또는 대괄호 표기법)으로 접근하면 JS 엔진이 일시적으로 원시값을 연관된 객체로 변환해 주기 때문이다.
  - 즉, `원시값을 객체처럼 사용하면 JS엔진은 암묵적으로 연관된 객체를 생성하여 생성된 객체로 프로퍼티에 접근하거나 메서드를 호출하고 다시 원시값으로 되돌린다.`
    - 이처럼 `문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 래퍼 객체(wrapper object)`라고 한다.
    - 예를 들어, 문자열에대해 마침표 표기법으로 접근하면 그 순간 래퍼 객체인 String 생성자 함수의 인스턴스가 생성되고 문자열은 래퍼 객체의 [[StringData]] 내부 슬롯에 힐당된다.

```js
const str = "kamja";
// 원시 타입인 문자열이 래퍼 객체인 String 인스턴스로 변환된다.
console.log(str.length); // 2
console.log(str.toUpperCase()); // HI
// 래퍼 객체로 프로퍼티에 접근하거나 메서드를 호출한 후, 다시 원시값으로 되돌린다.
console.log(typeof str); // string
```

- 이때 문자열 래퍼 객체인 String 생성자 함수의 인스턴스는 String.prototype의 메서드를 상속받아 사용할 수 있다.
- 그 후 래퍼 객체의 처리가 종료되면 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된 원시값으로 원래의 상태 즉, 식별자가 원시값을 갖도록 되돌리고 래퍼 객체는 가비지 컬랙션의 대상이 된다.

```js
// ① 식별자 str은 문자열을 값으로 가지고 있다.
const str = "kamja";
// ② 식별자 str은 암묵적으로 생성된 래퍼 객체를 가리킨다.
// 식별자의 값 "kamja"는 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된다.
// 래퍼 객체의 name 프로퍼티가 동적 추가된다.
str.name = "sweet";
// ③ 식별자 str은 다시 원래의 문자열 즉, 래퍼 객체의 [[StringData]]  내부 슬롯에 할당된 원시값을 갖는다.
// 이때 ②에서 생성한 래퍼 객체는 아무도 사용하지 않으므로 가비지 컬렉션의 대상이 된다.

// ④ 식별자 str은 새롭게 암묵적으로 생성된(②에서 생성된 래퍼 객체와는 다른) 래퍼 객체를 가리킨다.
// 새롭게 생성된 래퍼 객체에는 name 프로퍼티가 존재하지 않는다.
console.log(str.name); // undefined

// ⑤ 식별자 str은 다시 원래의 문자열 즉, 래퍼 객체의 [[SstringData]] 내부 슬롯에 할당된 원시값을 갖는다.
// 이때 ④에서 생성된 래퍼 객체는 아무도 참조하지 않는 상태이므로 가비지 컬렉션의 대상이 된다.
console.log(typeof str, str); // string hello
```

- 숫자 값도 마찬가지이다.(불리언, 심벌도 마찬가지)
  - 숫자 값에 대해 마침표 표기법으로 접근하면 래퍼 객체인 Number 생성자 함수의 인스턴스가 생성되고 숫자는 래퍼 객체의 [[NumberData]] 내부 슬롯에 할당된다.
    - 이때 래퍼 객체인 Number 객체는 당연히 Number.prototype의 메서드를 상속받아 사용할 수 있다.
      - 그 후, 래퍼 객체의 처리가 종료되면 [[NumberData]] 내부 슬롯에 할당된 원시값을 되돌리고 래퍼 객체는 가비지 컬렉션의 대상이 된다.

이처럼 문자열, 숫자, 불리언, 심벌은 암묵적으로 생성되는 래퍼 객체에 의해 마치 객체처럼 사용할 수 있다.

- 또한 표준 빌트인 객체인 String, Number, Boolean, Symbol의 프로토타입 메서드 또는 프로퍼티를 참조할 수 있다.
  - 즉, String, Number, Boolean 생성자 함수를 new 연산자와 함께 호출하여 인스턴스를 생성할 필요가 없으며 권장하지도 안흔다.
    - Symbol은 생성자 함수가 아니다.

문자열, 숫자, 불리언, 심벌 이외의 원시값 즉, null과 undefined는 래퍼 객체를 생성하지 않는다.

- 즉, null과 undefined 값을 객체처럼 사용하면 에러가 발생한다.

# 전역 객체

- 코드가 실행되기 이전 단계에서 JS엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며 어떤 객체에도 속하지 않은 최상위 객체이다.
  - JS환겨에 따라 지칭하는 이름이 다르다.
    - 브라우저 환경에서는 window(selft, this, frames)가 전역 객체를 가리킨다.
    - Node.js환경에서는 global이 전역 객체를 가리킨다.

### globalThis

- ES11에서 도입되었다.
- 브라우저 환경과 Node.js 환경에서 전역 객체를 가리키던 다양한 식별자를 통일한 식별자이다.
- globalThis는 표준 사양이므로 ECMAScript 표준 사양을 준수하는 모든 환경에서 사용할 수 있다.

```js
globalThis === this; // true
globalThis === window; // true
globalThis === self; // true
globalThis === frames;

// Node.js 환경(12.0.0 이상)
globalThis === this; // true
globalThis === global; // true
```

전역 객체는 표준 빌트인 객체와 환경에 따른 호스트 객체, var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다.

- 즉, 전역 객체는 계층적 구조상 어떤 객체에도 속하지 않은 모든 빌트인 객체(표준 빌트인 객체와 호스트 객체)의 최상위 객체이다.
  - 전역 객체가 최상위 객체라는 것은 프로토타입 상속 관계상에서 최상위 객체라는 의미는 아니다.
    - 전역 객체 자신은 어떤 객체의 프로퍼티도 아니며 객체의 계층적 구조상 표준 빌트인 객체와 호스트 객체를 프로퍼티로 소유한다는 것을 의미한다.

### 전역 객체의 특징

1. 전역 객체는 개발자가 의도적으로 생성할 수 없다.

- 전역 객체를 생성할 수 있는 생성자 함수가 제공되지 않는다.

2. 전역 객체의 프로퍼티르 참조할 때 window(global)를 생략할 수 있다.
3. 전역 객체는 모든 표준 빌트인 객체를 프로퍼티로 가지고 있다.

- Object, String, Number 등

4. JS 실행 환경에 따라 추가적으로 프로퍼티와 메서드를갖는다.
5. var 키워드로 선언한 전역 변수와 선언하지 않은 변수에 값을 할당한 암묵적 전역, 그리고 전역 함수는 전역 객체의프로퍼티가 된다.

- let이나 const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다.
  - let이나 const 키워드로 선언한 전역변수는 보이지 않는 개념적인 블록(전역 렉시컬 환경의 선언적 환경 레코드) 내에 존재하게 된다.

6. 브라우저 환경의 모든 자바스크립트코드는 하나의 전역 객체 window를 공유한다.

- 즉, 여러 개의 script 태그를 통해 JS코드를 분리해도 하나의 전역 객체 window를 공유한다.
  - 즉, 분리되어 있는 JS코드가 하나의 전역을 공유한다는 의미이다.

#### 빌트인 전역 프로퍼티

- 빌트인 전역 프로퍼티는 전역 객체의 프로퍼티를 의미한다.
- 주로 애플리케이션 전역에서 사용하는 값을 제공한다.

`Infinity`

- 무한대를 나타내는 숫자값 Infinity를 갖는다.

```js
// 양의 무한대
console.log(3 / 0); // Infinity
// 음의 무한대
console.log(-3 / 0); // -Infinity
// Infinity는 숫자값이다.
console.log(typeof Infinity); // number
```

`NaN`

- 숫자가 아님(Not-a-Number)을 나타내는 숫자값 NaN을 갖는다.
- Number.NaN 프로퍼티와 같다.

```js
console.log(Number("xyz")); // NaN
console.log(typeof NaN); // number
```

`undefined`

- undefined 프로퍼티는 원시 타입 undefined를 값으로 갖는다.

```js
var kamja;
console.log(kamja); // undefined
console.og(typeof undefined); // undefined
```

#### 빌트인 전역 함수

- 애플리케이션 전역에서 호출할 수 있는 빌트인 함수로서 전역 객체의 메서드이다.

`eval`

- JS 코드를 나타내는 문자열을 인수로 전달받는다.
  - 전달받은 문자열 코드가 표현식이라면 문자열 코드를 런타임에 평가하여 값을 생성한다.
  - 전달받은 인수가 표현식이 아닌 문이라면 eval 함수는 문자열 코드를 런타임에 실행한다.
  - 문자열 코드가 여러 개의 문으로 이루어져 있다면 모든 문을 실행한다.

```js
/**
 * 주어진 문자열 코드를 런타임에 평가 또는 실행한다.
 * @param {string} code - 코드를 나타내는 문자열
 * @returns {*} 문자열 코드를 평가/실행한 결과값
 * eval(code)
 */

// 표현식인 문 -> 런타임에 평가하여 값을 생성
eval("1+2;"); // 3
// 표현식이 아닌 문 -> 문자열 코드를 런타임에 실행
eval("var x = 5;"); // undefined
// eval 함수에 의해 런타임에 변수 선언문이 실행되어 x 변수가 선언되었다.
console.log(x); // 5
// 객체 리터럴은 반드시 괄호로 둘러싸야한다.
const o = eval("({a : 1})");
console.log(o); // {a : 1}
// 함수 리터럴은 반드시 괄호로 둘러싼다.
const f = eval("(function() {return 1;})");
console.log(f()); // 1
// 인수로 전달받은 문자열 코드가 여러 개의 문으로 이루어져 있다면 모든문을 실행한 후 마지막 결과값을 반환한다.
eval("1+2; 3+4;"); // 7
```

- eval 함수는 자신이 호출된 위치에 해당하는 기존의 스코프를 런타임에 동적으로 수정한다.

```js
const x = 1;
function foo() {
  // eval 함수는 런타임에 foo 함수의 스코프를 동적으로 수정한다.
  eval("var x = 2;");
  console.log(x); // 2
}
foo();
console.log(x); // 1
```

- eval 함수는 새로운 x 변수를 선언하면서 foo 함수의 스코프에 선언된 x 변수를 동적으로 추가한다.
  - 함수가 호출되면 런타임 이전에 먼저 함수 몸체 내부의 모든 선언문을 실행하고 그 결과를 스코프에 등록한다.
    - 따라서 위 예제의 eval 함수가 호출되는 시점에는 이미 foo 함수의 스코프가 존재한다.
    - 하지만, eval 함수는 기존의 스코프를 런타임에 동적으로 수정한다. -그리고 eval 함수에 전달된 코드는 이미 그 위치에 존재하던 코드처럼 동작한다. - 즉, eval 함수가 호출된 foo 함수의 스코프에서 실행된다. - 단, strict mode에서 eval 함수는 기존의 스코프를 수정하지 않고 eval 함수 자신의 자체적인 스코프를 생성한다.

```js
const x = 1;
function kamja() {
  "use strict";
  // strict mode에서 eval 함수는 기존의 스코프를 수정하지 않고 eval 함수 자신의 자체적인 스코프를 생성한다.
  eval("var x = 2; console.log(x);"); // 2
  console.log(x); // 1
}
kamja();
console.log(x); // 1
```

인수로 전달받은 문자열 코드가 let, const 키워드를 사용한 변수 선언문이라면 암묵적으로 strict mode가 적용된다.

```js
const x = 1;
function kamja() {
  eval("var x = 2; console.log(x);"); // 2
  //let, const 키워드를 사용한 변수 선언문은 strict mode가 적용된다.
  eval("const x = 3; console.log(x);"); // 3
  console.log(x); // 2
}
kamja();
console.log(x); // 1
```

- eval 함수를 통해 사용자로부터 입력받은 콘텐츠를 실행하는 것은 보안에 매우 취약하다.
- eval 함수를 통해 실행되는 코드는 JS엔진에 의해 최적화가 수행되지 않으므로 처리 속도가 느리다.
- `즉, eval 함수의 사용은 금지해야 한다.`
