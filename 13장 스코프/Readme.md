1. [스코프](#스코프)
2. [전역 스코프](#전역)
3. [지역 스코프](#지역)
4. [스코프 체인](#스코프-체인)
5. [블록 레벨 스코프](#블록-레벨-스코프)
6. [함수 레벨 스코프](#함수-레벨-스코프)
7. [동적 스코프와 렉시컬 스코프](#동적-스코프와-렉시컬-스코프)
# 스코프

- 모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다.
- 즉, 스코프는 식별자가 유효한 범위를 말한다.
- 스코프는 식별자를 검색할 때 사용하는 규칙이라고도 할 수 있다.

## 스코프의 종류

| 구분 |         설명          |        스코프 |      변수 |
| :----: | :-------------------: | :------------: | :--------: |
| 전역 | 코드의 가장 바깥 영역 | `전역 스코프` | 전역 변수 |
| 지역 |    함수 몸체 내부     | `지역 스코프` | 지역 변수 |

- 변수는 자신이 선언된 위치(전역 or 지역)에 의해 자신이 유효한 범위인 스코프가 결정된다.
  - 즉, 전역에서 선언된 변수는 전역 스코프를 갖는 전역 변수이고, 지역에서 선언된 변수는 지역 스코프를 갖는 지역 변수이다.

### 전역

- 코드의 가장 바깥 영영을 의미한다.
- 전역은 전역 스코프(global scope)를 만든다.
- 전역에 변수를 선언하면 어디서든지 참조할 수 있는 전역 변수(global variable)가 된다.
- 위 예제에서 코드 가장 바깥 영역에 선언된 x와 y는 전역변수이다.

### 지역

- 함수 몸체 내부를 말한다.
- 지역은 지역 스코프(local scope)를 만든다.
- 지역에 변수를 선언하면 자신이 선언된 지역과 하위 지역에서만 참조할 수 있는 지역 변수가 된다.
- 즉, 지역 변수는 자신의 지역 스코프와 하위 스코프에서 유효하다.

```Javascript
var x = "global x";
var y = "global y";

function outer(){
    var z = "outer's local z";

    console.log(x); // ① global x
    console.log(y); // ② global y
    console.log(z); // ③ outer's local z

    function inner(){
        var x = "inner's local x";

        console.log(x); // ④ inner's local x
        console.log(y); // ⑤ global y
        console.log(z); // ⑥ outer's local z
    }
    inner();
}
outer();
console.log(x); // ⑦ global x
console.log(z); // ⑧ ReferenceError: z is not defined
```

- outer 함수 내부에 선언된 z는 지역 변수이다. 즉, z는 outer()와 inner()에서만 참조할 수 있다. <- z를 외부(전역)에서 호출하면 참조 에러가 발생한다.
- inner 함수 내부에 선언된 x는 지역 변수이다. 즉, inner()에서만 참조할 수 있다. <- x를 외부 or 지역(inner()함수)밖에서 호출하면 참조 에러가 발생한다.
- inner() 내부에 선언된 x변수 이외에 이름이 같은 전역 변수 x가 존재한다.
  - inner() 내부에서 x 변수를 참조하면 전역 변수 x를 참조하는 것이 아니라 inner() 내부에서 선언된 x 변수를 참조한다. <- 스코프 체인을 통해 참조할 변수를 검색했기 떄문

# 스코프 체인

- 모든 스코프는 하나의 계층적 구조로 연결되며, 모든 지역 스코프의 최상위 스코프는 전역 스포크이다.
- 스코프가 계층적으로 연결된 것을 스코프 체인이라고 한다.
- 즉, 위의 코드에서 스코프 체인은 최상위 스코프인 전역 스코프, 전역에서 선언된 outer 함수의 지역 스코프, outer 함수 내부에 선언된 inner 함수의 지역 스코프로 이뤄진다.
- 변수를 참조할 때 JS 엔진은 스콮 ㅡ체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다. <- 상위 스코프에서 선언한 변수를 하위 스코프에서도 참조할 수 있는 이유

### 위 코드의 ④번 동작과정

1. x변수를 참조하는 코드의 스코프인 inner 함수의 지역 스코프에서 x 변수가 선언되었는지 검색한다.
2. inner 함수 내에는 선언된 x변수가 존재하기에 검색된 변수를 참조하고 검색을 종료한다.

### 위 코드의 ⑤번 동작과정

1. inner 함수의 지역 스코프에서 y변수가 선언되었는지 검색
2. y변수 선언 존재 x -> 상위 스코프인 outer()로 이동
3. outer 함수의 지역 스코프에서 y변수가 선언되었는지 검색
4. y변수 선언 존재 x -> 상위 스코프인 전역 스코프로 이동
5. 전역 스코프에서 y변수가 선언되었는지 검색
6. y변수 선언 존재 O -> 검색된 변수를 참조하고 검색 종료

### 위 코드의 ⑥번 동작과정

1. inner 함수의 지역 스코프에서 z변수가 선언되었는지 검색
2. z변수 선언 존재 x -> 상위 스코프인 outer()로 이동
3. outer 스코프에서 z변수가 선언되었는지 검색
4. z변수 선언 존재 O -> 검색된 변수를 참조하고 검색 종료

- `상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다.`
  - 스코프 체인으로 연결된 스코프의 계층적 구조는 부자 관계로 이뤄진 상속과 유사하다.
  - 상속을 통해 부모의 자산을 자식이 자유롭게 사용이 가능하지만 자식의 자산을 부모가 사용할 수 없다. 스코프 체인도 이와 마찬가지이다.

## 블록 레벨 스코프

- 함수 몸체만이 아니라 모든 코드 블록이 지역 스코프를 만든다.(if, for, while 등)

## 함수 레벨 스코프

- 오로지 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정한다.
- JS의 var키워드로 선언했을 경우

```Javascript
var x = 1;
if(1){
    var x = 10;
}
console.log(x); // 10
```

- var 키워드로 선언된 변수는 함수 레벨 스코프를 인정하기에 함수 밖에서 var 키워드로 선언된 변수는 코드 블록 내에서 선언되었다 할지라도 모두 전역 변수이다. 따라서 <u>전역 변수 x는 중복 선언되고 그 결과 의도치 않은 전역 변수의 값이 재할당된다.</u>
  - `var 키워드는 함수 레벨 스코프를 사용한다.`
  - `let, const 키워드는 블록 레벨 스코프를 사용한다.`

# 동적 스코프와 렉시컬 스코프

```Javascript
var x = 1;
function foo(){
    var x = 10;
    bar();
}
function bar(){
    console.log(x);
}
foo();
bar();
```

## 동적 스코프

- 함수를 정의하는 시점에는 함수가 어디서 호출될지 알 수 없다.
  - `함수가 호출되는 시점에 동적으로 상위 스코프를 결정한다.`

## 렉시컬 스코프

- 동적 스코프처럼 상위 스코프가 동적으로 변하지 않고 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정된다.
  - 즉, `함수를 어디서 정의했는지에 따라 상위 스코프를 결정한다.`
  - 대부분의 언어(JS 포함)는 렉시컬 스코프를 따른다.
